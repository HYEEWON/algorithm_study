# BAEKJOON

## Dynamic Programming
### 2293, 동전1(Silver1, Python)
* 틀린 이유: DP 배열로 2차원 배열을 사용해 메모리 초과
* 풀이: DP 배열로 1차원 배열을 사용, dp[sum-number]을 더함

## Graph
### 1516. 게임 개발 (Gold3, Java)
* 틀린 이유: 이전에 지은 건물들을 짓는 시간의 MAX 값을 이용하는 것을 생각X
* 풀이: 위상 정렬을 사용, 그래프 방향: 먼저 짓는 건물 -> 나중에 짓는 건물, 이전에 지은 건물들을 짓는 시간의 MAX 값을 이용

### 1854. K번째 최단 경로 찾기
* 틀린 이유: dist를 저장할 자료구조 생각X
* 풀이: 거리를 저장하는 자료구조로 우선 순위 큐로 이루어진 배열을 사용 -> (-1)거리로 저장하여 K번째 거리 찾기

### 2458. 키 순서 (Gold3, Java)
* 틀린 이유: 풀이 생각X
* 풀이: 그래프의 정방향, 역방향으로 순회 -> 총 노드의 카운트 = 전체 노드 수 - 1

### 3830. 교수님은 기다리지 않는다
* 틀린 이유: diff 계산
* 풀이: 유니온 파인드

### 5719. 거의 최단 경로
* 풀이: 다익스트라 -> BFS로 최단 경로에 포함된 정점 제거 -> 다익스트라로 경로 찾기

### 11266. 단절점
* 풀이: 노드들의 방문 순서를 저장 -> DFS(now, isRoot)로 단절점 판별

### 11400. 단절선
* 풀이: 11266과 거의 비슷 -> DFS(now, prev)로 단절선 판별

### 11438. LCA2
* 풀이: 최소 공통 조상, 트리의 최대 깊이(K) 계산 -> dfs로 각 노드들의 깊이 저장 -> DP를 이용해 각 노드별 2^0 ~ 2^K 번째 조상 노드를 저장 -> 깊이가 깊은 노드를 낮은 깊이로 이동

## Heap

### 1655. 가운데를말해요 (Gold2, Java)
* 틀린 이유: 힙을 이용한 풀이과정 구현X
* 풀이: 두개의 힙이 필요 -> 최소 힙: 중간 값보다 큰 수를 저장, 최대 힙: 중간 값보다 작은 수를 저장 -> 최대 힙의 root를 출력

### 2014. 소수의 곱 (Gold2, Python)
* 틀린 이유: 문제 이해X
* 풀이: 힙에서 숫자를 1개씩 뽑아서 수의 곱을 구함, 겹치는 곱이 있을 수 있어서 제거해야함

## Number Theory

### 5376. 소수를 분수로 (Silver, java)
* 틀린 이유: 파이썬으로 하면 틀림, 다시 볼 필요 있음
* 수정: 자바로 재풀이

## Tree

### 1275. 커피숍2 (Gold1, Java)
* 틀린 이유: 세그먼트 트리 구현 시 query 함수에서 tree 값을 update
* 수정: query함수에서 값 update 삭제

### 1991. 트리 순회 (Silver1, Python)
* 틀린 이유: 트리를 구현했는데 트리 노드를 추가하는 부분에서 객체가 아닌 str이 넘어가서 에러 발생
* 수정: 순환을 하며 객체를 추가하지 않고, 그냥 객체를 여러 개 생성

### 2243. 사탕상자 (Platinum5, Java)
* 틀린이유: 세그먼트 트리 구현X
* 풀이: 세그먼트 트리로 수를 정렬, 갱신

### 9202. Boggle (Platinum5, Python)
* 틀린 이유: Trie 구현X
* 풀이: Trie를 구현하여 순회, 순회에는 백트랙킹 사용

## Two Pointer

### 2003. 수들의 합 (Silver3, Python)
* 틀린 이유: 이중 For문으로 순차적 덧셈 -> 시간 초과
* 수정: 미리 배열의 연속합을 구해 원소를 1개씩 빼며 M과 비교 / 배열의 처음과 끝을 가리키는 두 개의 포인터 생성 -> 투 포인터 방식

### 2143. 두 배열의 합 (Gold3. Java)
* 틀린 이유: 투 포인터를 이용한 풀이과정 구현X
* 플이: 각 배열의 모든 부분 합을 구하여 정렬 -> 각 부분 합 배열을 가리키는 두 개의 포인터 생성 -> 합이 T가 되는 것을 Count
* 오래걸린 이유: answer에서 long이 아닌 int를 사용해서 수정에 오래 걸림